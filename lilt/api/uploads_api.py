# coding: utf-8

"""
    LILT API

    LILT API Support: https://lilt.atlassian.net/servicedesk/customer/portals  The LILT API enables programmatic access to the full-range of LILT backend services including:   * Training of and translating with interactive, adaptive machine translation   * Large-scale translation memory   * The Lexicon (a large-scale termbase)   * Programmatic control of the LILT CAT environment   * Translation memory synchronization   Requests and responses are in JSON format. The REST API only responds to HTTPS / SSL requests.  The base url for this REST API is `https://api.lilt.com/`.  ## Authentication  Requests are authenticated via API key, which requires the Business plan.  Requests are authenticated using [HTTP Basic Auth](https://en.wikipedia.org/wiki/Basic_access_authentication). Add your API key as both the `username` and `password`.  For development, you may also pass the API key via the `key` query parameter. This is less secure than HTTP Basic Auth, and is not recommended for production use.  ## Quotas  Our services have a general quota of 4000 requests per minute. Should you hit the maximum requests per minute, you will need to wait 60 seconds before you can send another request. 

    The version of the OpenAPI document: v3.0.3
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictStr
from typing import List, Optional
from typing_extensions import Annotated
from lilt.models.cancel_multipart_upload200_response import CancelMultipartUpload200Response
from lilt.models.complete_multipart_upload200_response import CompleteMultipartUpload200Response
from lilt.models.complete_multipart_upload_body import CompleteMultipartUploadBody
from lilt.models.get_pending_uploads200_response_inner import GetPendingUploads200ResponseInner
from lilt.models.get_s3_upload_params200_response import GetS3UploadParams200Response
from lilt.models.initiate_multipart_upload200_response import InitiateMultipartUpload200Response
from lilt.models.initiate_multipart_upload_body import InitiateMultipartUploadBody
from lilt.models.initiate_upload_body import InitiateUploadBody
from lilt.models.sign_upload_part200_response import SignUploadPart200Response

from lilt.api_client import ApiClient, RequestSerialized
from lilt.api_response import ApiResponse
from lilt.rest import RESTResponseType


class UploadsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def cancel_multipart_upload(
        self,
        upload_id: Annotated[StrictStr, Field(description="Multipart upload ID to cancel")],
        s3_key: Annotated[StrictStr, Field(description="Upload key from initiate response")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CancelMultipartUpload200Response:
        """Cancel Multipart Upload

        Cancel/abort a multipart upload and clean up any uploaded parts.  Example CURL command: ```   curl -X DELETE \"https://lilt.com/v2/upload/s3/multipart/abc123def456?key=API_KEY&key=uploads/user123/file456.zip\" ``` 

        :param upload_id: Multipart upload ID to cancel (required)
        :type upload_id: str
        :param s3_key: Upload key from initiate response (required)
        :type s3_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cancel_multipart_upload_serialize(
            upload_id=upload_id,
            s3_key=s3_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CancelMultipartUpload200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cancel_multipart_upload_with_http_info(
        self,
        upload_id: Annotated[StrictStr, Field(description="Multipart upload ID to cancel")],
        s3_key: Annotated[StrictStr, Field(description="Upload key from initiate response")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CancelMultipartUpload200Response]:
        """Cancel Multipart Upload

        Cancel/abort a multipart upload and clean up any uploaded parts.  Example CURL command: ```   curl -X DELETE \"https://lilt.com/v2/upload/s3/multipart/abc123def456?key=API_KEY&key=uploads/user123/file456.zip\" ``` 

        :param upload_id: Multipart upload ID to cancel (required)
        :type upload_id: str
        :param s3_key: Upload key from initiate response (required)
        :type s3_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cancel_multipart_upload_serialize(
            upload_id=upload_id,
            s3_key=s3_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CancelMultipartUpload200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cancel_multipart_upload_without_preload_content(
        self,
        upload_id: Annotated[StrictStr, Field(description="Multipart upload ID to cancel")],
        s3_key: Annotated[StrictStr, Field(description="Upload key from initiate response")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Cancel Multipart Upload

        Cancel/abort a multipart upload and clean up any uploaded parts.  Example CURL command: ```   curl -X DELETE \"https://lilt.com/v2/upload/s3/multipart/abc123def456?key=API_KEY&key=uploads/user123/file456.zip\" ``` 

        :param upload_id: Multipart upload ID to cancel (required)
        :type upload_id: str
        :param s3_key: Upload key from initiate response (required)
        :type s3_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cancel_multipart_upload_serialize(
            upload_id=upload_id,
            s3_key=s3_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CancelMultipartUpload200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cancel_multipart_upload_serialize(
        self,
        upload_id,
        s3_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if upload_id is not None:
            _path_params['uploadId'] = upload_id
        # process the query parameters
        if s3_key is not None:
            
            _query_params.append(('s3Key', s3_key))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth', 
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/v2/upload/s3/multipart/{uploadId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def complete_multipart_upload(
        self,
        upload_id: Annotated[StrictStr, Field(description="Multipart upload ID from initiate response")],
        s3_key: Annotated[StrictStr, Field(description="Upload key from initiate response")],
        complete_multipart_upload_body: Annotated[CompleteMultipartUploadBody, Field(description="Information about uploaded parts.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CompleteMultipartUpload200Response:
        """Complete Multipart Upload

        Complete a multipart upload by providing all uploaded parts information.  Example CURL command: ```   curl -X POST \"https://lilt.com/v2/upload/s3/multipart/abc123def456/complete?key=API_KEY&key=uploads/user123/file456.zip\" \\   --header \"Content-Type: application/json\" \\   --data-raw '{     \"parts\": [       {\"ETag\": \"etag1\", \"PartNumber\": 1},       {\"ETag\": \"etag2\", \"PartNumber\": 2}     ]   }' ``` 

        :param upload_id: Multipart upload ID from initiate response (required)
        :type upload_id: str
        :param s3_key: Upload key from initiate response (required)
        :type s3_key: str
        :param complete_multipart_upload_body: Information about uploaded parts. (required)
        :type complete_multipart_upload_body: CompleteMultipartUploadBody
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._complete_multipart_upload_serialize(
            upload_id=upload_id,
            s3_key=s3_key,
            complete_multipart_upload_body=complete_multipart_upload_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CompleteMultipartUpload200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def complete_multipart_upload_with_http_info(
        self,
        upload_id: Annotated[StrictStr, Field(description="Multipart upload ID from initiate response")],
        s3_key: Annotated[StrictStr, Field(description="Upload key from initiate response")],
        complete_multipart_upload_body: Annotated[CompleteMultipartUploadBody, Field(description="Information about uploaded parts.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CompleteMultipartUpload200Response]:
        """Complete Multipart Upload

        Complete a multipart upload by providing all uploaded parts information.  Example CURL command: ```   curl -X POST \"https://lilt.com/v2/upload/s3/multipart/abc123def456/complete?key=API_KEY&key=uploads/user123/file456.zip\" \\   --header \"Content-Type: application/json\" \\   --data-raw '{     \"parts\": [       {\"ETag\": \"etag1\", \"PartNumber\": 1},       {\"ETag\": \"etag2\", \"PartNumber\": 2}     ]   }' ``` 

        :param upload_id: Multipart upload ID from initiate response (required)
        :type upload_id: str
        :param s3_key: Upload key from initiate response (required)
        :type s3_key: str
        :param complete_multipart_upload_body: Information about uploaded parts. (required)
        :type complete_multipart_upload_body: CompleteMultipartUploadBody
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._complete_multipart_upload_serialize(
            upload_id=upload_id,
            s3_key=s3_key,
            complete_multipart_upload_body=complete_multipart_upload_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CompleteMultipartUpload200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def complete_multipart_upload_without_preload_content(
        self,
        upload_id: Annotated[StrictStr, Field(description="Multipart upload ID from initiate response")],
        s3_key: Annotated[StrictStr, Field(description="Upload key from initiate response")],
        complete_multipart_upload_body: Annotated[CompleteMultipartUploadBody, Field(description="Information about uploaded parts.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Complete Multipart Upload

        Complete a multipart upload by providing all uploaded parts information.  Example CURL command: ```   curl -X POST \"https://lilt.com/v2/upload/s3/multipart/abc123def456/complete?key=API_KEY&key=uploads/user123/file456.zip\" \\   --header \"Content-Type: application/json\" \\   --data-raw '{     \"parts\": [       {\"ETag\": \"etag1\", \"PartNumber\": 1},       {\"ETag\": \"etag2\", \"PartNumber\": 2}     ]   }' ``` 

        :param upload_id: Multipart upload ID from initiate response (required)
        :type upload_id: str
        :param s3_key: Upload key from initiate response (required)
        :type s3_key: str
        :param complete_multipart_upload_body: Information about uploaded parts. (required)
        :type complete_multipart_upload_body: CompleteMultipartUploadBody
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._complete_multipart_upload_serialize(
            upload_id=upload_id,
            s3_key=s3_key,
            complete_multipart_upload_body=complete_multipart_upload_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CompleteMultipartUpload200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _complete_multipart_upload_serialize(
        self,
        upload_id,
        s3_key,
        complete_multipart_upload_body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if upload_id is not None:
            _path_params['uploadId'] = upload_id
        # process the query parameters
        if s3_key is not None:
            
            _query_params.append(('s3Key', s3_key))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if complete_multipart_upload_body is not None:
            _body_params = complete_multipart_upload_body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth', 
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/upload/s3/multipart/{uploadId}/complete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_pending_uploads(
        self,
        ids: Annotated[Optional[StrictStr], Field(description="Comma-separated list of upload IDs to filter by.")] = None,
        statuses: Annotated[Optional[StrictStr], Field(description="Comma-separated list of upload statuses to filter by.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[GetPendingUploads200ResponseInner]:
        """Get All Pending Uploads or specific list of uploads by ids or statuses

        Retrieve all pending uploads for the current user and organization.  Example CURL command: ```   curl -X GET https://lilt.com/2/upload?key=API_KEY ``` 

        :param ids: Comma-separated list of upload IDs to filter by.
        :type ids: str
        :param statuses: Comma-separated list of upload statuses to filter by.
        :type statuses: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_pending_uploads_serialize(
            ids=ids,
            statuses=statuses,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetPendingUploads200ResponseInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_pending_uploads_with_http_info(
        self,
        ids: Annotated[Optional[StrictStr], Field(description="Comma-separated list of upload IDs to filter by.")] = None,
        statuses: Annotated[Optional[StrictStr], Field(description="Comma-separated list of upload statuses to filter by.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[GetPendingUploads200ResponseInner]]:
        """Get All Pending Uploads or specific list of uploads by ids or statuses

        Retrieve all pending uploads for the current user and organization.  Example CURL command: ```   curl -X GET https://lilt.com/2/upload?key=API_KEY ``` 

        :param ids: Comma-separated list of upload IDs to filter by.
        :type ids: str
        :param statuses: Comma-separated list of upload statuses to filter by.
        :type statuses: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_pending_uploads_serialize(
            ids=ids,
            statuses=statuses,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetPendingUploads200ResponseInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_pending_uploads_without_preload_content(
        self,
        ids: Annotated[Optional[StrictStr], Field(description="Comma-separated list of upload IDs to filter by.")] = None,
        statuses: Annotated[Optional[StrictStr], Field(description="Comma-separated list of upload statuses to filter by.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get All Pending Uploads or specific list of uploads by ids or statuses

        Retrieve all pending uploads for the current user and organization.  Example CURL command: ```   curl -X GET https://lilt.com/2/upload?key=API_KEY ``` 

        :param ids: Comma-separated list of upload IDs to filter by.
        :type ids: str
        :param statuses: Comma-separated list of upload statuses to filter by.
        :type statuses: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_pending_uploads_serialize(
            ids=ids,
            statuses=statuses,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetPendingUploads200ResponseInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_pending_uploads_serialize(
        self,
        ids,
        statuses,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if statuses is not None:
            
            _query_params.append(('statuses', statuses))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth', 
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/upload',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_s3_upload_params(
        self,
        filename: Annotated[StrictStr, Field(description="A file name including file extension.")],
        type: Annotated[StrictStr, Field(description="The content-type or mime-type of the file to upload.")],
        metadata_size: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The size of the file to upload in bytes.")] = None,
        metadata_category: Annotated[Optional[StrictStr], Field(description="File category metadata.")] = None,
        metadata_uuid: Annotated[Optional[StrictStr], Field(description="File UUID metadata.")] = None,
        metadata_labels: Annotated[Optional[StrictStr], Field(description="Comma-separated list of label names to be added to the file after upload completes.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetS3UploadParams200Response:
        """Get S3 Upload Parameters

        Get S3 upload parameters via query string. This endpoint provides the necessary information to complete the file upload process using GET parameters.  Example CURL command: ```   curl -X GET \"https://lilt.com/v2/upload/s3/params?key=API_KEY&filename=example.json&type=application/json&metadata.size=1024&metadata.labels=important,review-needed\" ``` 

        :param filename: A file name including file extension. (required)
        :type filename: str
        :param type: The content-type or mime-type of the file to upload. (required)
        :type type: str
        :param metadata_size: The size of the file to upload in bytes.
        :type metadata_size: int
        :param metadata_category: File category metadata.
        :type metadata_category: str
        :param metadata_uuid: File UUID metadata.
        :type metadata_uuid: str
        :param metadata_labels: Comma-separated list of label names to be added to the file after upload completes.
        :type metadata_labels: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_s3_upload_params_serialize(
            filename=filename,
            type=type,
            metadata_size=metadata_size,
            metadata_category=metadata_category,
            metadata_uuid=metadata_uuid,
            metadata_labels=metadata_labels,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetS3UploadParams200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_s3_upload_params_with_http_info(
        self,
        filename: Annotated[StrictStr, Field(description="A file name including file extension.")],
        type: Annotated[StrictStr, Field(description="The content-type or mime-type of the file to upload.")],
        metadata_size: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The size of the file to upload in bytes.")] = None,
        metadata_category: Annotated[Optional[StrictStr], Field(description="File category metadata.")] = None,
        metadata_uuid: Annotated[Optional[StrictStr], Field(description="File UUID metadata.")] = None,
        metadata_labels: Annotated[Optional[StrictStr], Field(description="Comma-separated list of label names to be added to the file after upload completes.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetS3UploadParams200Response]:
        """Get S3 Upload Parameters

        Get S3 upload parameters via query string. This endpoint provides the necessary information to complete the file upload process using GET parameters.  Example CURL command: ```   curl -X GET \"https://lilt.com/v2/upload/s3/params?key=API_KEY&filename=example.json&type=application/json&metadata.size=1024&metadata.labels=important,review-needed\" ``` 

        :param filename: A file name including file extension. (required)
        :type filename: str
        :param type: The content-type or mime-type of the file to upload. (required)
        :type type: str
        :param metadata_size: The size of the file to upload in bytes.
        :type metadata_size: int
        :param metadata_category: File category metadata.
        :type metadata_category: str
        :param metadata_uuid: File UUID metadata.
        :type metadata_uuid: str
        :param metadata_labels: Comma-separated list of label names to be added to the file after upload completes.
        :type metadata_labels: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_s3_upload_params_serialize(
            filename=filename,
            type=type,
            metadata_size=metadata_size,
            metadata_category=metadata_category,
            metadata_uuid=metadata_uuid,
            metadata_labels=metadata_labels,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetS3UploadParams200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_s3_upload_params_without_preload_content(
        self,
        filename: Annotated[StrictStr, Field(description="A file name including file extension.")],
        type: Annotated[StrictStr, Field(description="The content-type or mime-type of the file to upload.")],
        metadata_size: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The size of the file to upload in bytes.")] = None,
        metadata_category: Annotated[Optional[StrictStr], Field(description="File category metadata.")] = None,
        metadata_uuid: Annotated[Optional[StrictStr], Field(description="File UUID metadata.")] = None,
        metadata_labels: Annotated[Optional[StrictStr], Field(description="Comma-separated list of label names to be added to the file after upload completes.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get S3 Upload Parameters

        Get S3 upload parameters via query string. This endpoint provides the necessary information to complete the file upload process using GET parameters.  Example CURL command: ```   curl -X GET \"https://lilt.com/v2/upload/s3/params?key=API_KEY&filename=example.json&type=application/json&metadata.size=1024&metadata.labels=important,review-needed\" ``` 

        :param filename: A file name including file extension. (required)
        :type filename: str
        :param type: The content-type or mime-type of the file to upload. (required)
        :type type: str
        :param metadata_size: The size of the file to upload in bytes.
        :type metadata_size: int
        :param metadata_category: File category metadata.
        :type metadata_category: str
        :param metadata_uuid: File UUID metadata.
        :type metadata_uuid: str
        :param metadata_labels: Comma-separated list of label names to be added to the file after upload completes.
        :type metadata_labels: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_s3_upload_params_serialize(
            filename=filename,
            type=type,
            metadata_size=metadata_size,
            metadata_category=metadata_category,
            metadata_uuid=metadata_uuid,
            metadata_labels=metadata_labels,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetS3UploadParams200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_s3_upload_params_serialize(
        self,
        filename,
        type,
        metadata_size,
        metadata_category,
        metadata_uuid,
        metadata_labels,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if filename is not None:
            
            _query_params.append(('filename', filename))
            
        if type is not None:
            
            _query_params.append(('type', type))
            
        if metadata_size is not None:
            
            _query_params.append(('metadata.size', metadata_size))
            
        if metadata_category is not None:
            
            _query_params.append(('metadata.category', metadata_category))
            
        if metadata_uuid is not None:
            
            _query_params.append(('metadata.uuid', metadata_uuid))
            
        if metadata_labels is not None:
            
            _query_params.append(('metadata.labels', metadata_labels))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth', 
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/upload/s3/params',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_upload_by_id(
        self,
        upload_id: Annotated[int, Field(strict=True, ge=1, description="Unique upload identifier")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetPendingUploads200ResponseInner:
        """Get Upload by ID

        Retrieve a specific upload by its unique identifier.  Example CURL command: ```   curl -X GET https://lilt.com/2/upload/12345?key=API_KEY ``` 

        :param upload_id: Unique upload identifier (required)
        :type upload_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_upload_by_id_serialize(
            upload_id=upload_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetPendingUploads200ResponseInner",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_upload_by_id_with_http_info(
        self,
        upload_id: Annotated[int, Field(strict=True, ge=1, description="Unique upload identifier")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetPendingUploads200ResponseInner]:
        """Get Upload by ID

        Retrieve a specific upload by its unique identifier.  Example CURL command: ```   curl -X GET https://lilt.com/2/upload/12345?key=API_KEY ``` 

        :param upload_id: Unique upload identifier (required)
        :type upload_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_upload_by_id_serialize(
            upload_id=upload_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetPendingUploads200ResponseInner",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_upload_by_id_without_preload_content(
        self,
        upload_id: Annotated[int, Field(strict=True, ge=1, description="Unique upload identifier")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Upload by ID

        Retrieve a specific upload by its unique identifier.  Example CURL command: ```   curl -X GET https://lilt.com/2/upload/12345?key=API_KEY ``` 

        :param upload_id: Unique upload identifier (required)
        :type upload_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_upload_by_id_serialize(
            upload_id=upload_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetPendingUploads200ResponseInner",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_upload_by_id_serialize(
        self,
        upload_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if upload_id is not None:
            _path_params['uploadId'] = upload_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth', 
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/upload/{uploadId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def initiate_multipart_upload(
        self,
        initiate_multipart_upload_body: Annotated[InitiateMultipartUploadBody, Field(description="Information about the file(s) to be uploaded. Can be a single object or an array of objects (max 100).  Single file request: `{ \"filename\": \"...\", \"type\": \"...\", \"metadata\": {...} }` Bulk request: `[{ \"filename\": \"...\", \"type\": \"...\", \"metadata\": {...} }, ...]` ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> InitiateMultipartUpload200Response:
        """Initiate Multipart Upload

        Initiate a multipart upload for large files. This endpoint provides the necessary information to start a multipart upload process.  Supports both single file and bulk upload requests. For bulk uploads, pass an array of upload objects (maximum 100 items). The response format matches the request format - a single object for single file requests, or an array for bulk requests.  Example CURL command (single file): ```   curl -X POST https://lilt.com/v2/upload/s3/multipart?key=API_KEY \\   --header \"Content-Type: application/json\" \\   --data-raw '{     \"filename\": \"large-file.zip\",     \"type\": \"application/zip\",     \"metadata\": {       \"size\": 104857600     }   }' ```  Example CURL command (bulk upload): ```   curl -X POST https://lilt.com/v2/upload/s3/multipart?key=API_KEY \\   --header \"Content-Type: application/json\" \\   --data-raw '[     {       \"filename\": \"large-file1.zip\",       \"type\": \"application/zip\",       \"metadata\": { \"size\": 104857600 }     },     {       \"filename\": \"large-file2.zip\",       \"type\": \"application/zip\",       \"metadata\": { \"size\": 209715200 }     }   ]' ``` 

        :param initiate_multipart_upload_body: Information about the file(s) to be uploaded. Can be a single object or an array of objects (max 100).  Single file request: `{ \"filename\": \"...\", \"type\": \"...\", \"metadata\": {...} }` Bulk request: `[{ \"filename\": \"...\", \"type\": \"...\", \"metadata\": {...} }, ...]`  (required)
        :type initiate_multipart_upload_body: InitiateMultipartUploadBody
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._initiate_multipart_upload_serialize(
            initiate_multipart_upload_body=initiate_multipart_upload_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "InitiateMultipartUpload200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def initiate_multipart_upload_with_http_info(
        self,
        initiate_multipart_upload_body: Annotated[InitiateMultipartUploadBody, Field(description="Information about the file(s) to be uploaded. Can be a single object or an array of objects (max 100).  Single file request: `{ \"filename\": \"...\", \"type\": \"...\", \"metadata\": {...} }` Bulk request: `[{ \"filename\": \"...\", \"type\": \"...\", \"metadata\": {...} }, ...]` ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[InitiateMultipartUpload200Response]:
        """Initiate Multipart Upload

        Initiate a multipart upload for large files. This endpoint provides the necessary information to start a multipart upload process.  Supports both single file and bulk upload requests. For bulk uploads, pass an array of upload objects (maximum 100 items). The response format matches the request format - a single object for single file requests, or an array for bulk requests.  Example CURL command (single file): ```   curl -X POST https://lilt.com/v2/upload/s3/multipart?key=API_KEY \\   --header \"Content-Type: application/json\" \\   --data-raw '{     \"filename\": \"large-file.zip\",     \"type\": \"application/zip\",     \"metadata\": {       \"size\": 104857600     }   }' ```  Example CURL command (bulk upload): ```   curl -X POST https://lilt.com/v2/upload/s3/multipart?key=API_KEY \\   --header \"Content-Type: application/json\" \\   --data-raw '[     {       \"filename\": \"large-file1.zip\",       \"type\": \"application/zip\",       \"metadata\": { \"size\": 104857600 }     },     {       \"filename\": \"large-file2.zip\",       \"type\": \"application/zip\",       \"metadata\": { \"size\": 209715200 }     }   ]' ``` 

        :param initiate_multipart_upload_body: Information about the file(s) to be uploaded. Can be a single object or an array of objects (max 100).  Single file request: `{ \"filename\": \"...\", \"type\": \"...\", \"metadata\": {...} }` Bulk request: `[{ \"filename\": \"...\", \"type\": \"...\", \"metadata\": {...} }, ...]`  (required)
        :type initiate_multipart_upload_body: InitiateMultipartUploadBody
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._initiate_multipart_upload_serialize(
            initiate_multipart_upload_body=initiate_multipart_upload_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "InitiateMultipartUpload200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def initiate_multipart_upload_without_preload_content(
        self,
        initiate_multipart_upload_body: Annotated[InitiateMultipartUploadBody, Field(description="Information about the file(s) to be uploaded. Can be a single object or an array of objects (max 100).  Single file request: `{ \"filename\": \"...\", \"type\": \"...\", \"metadata\": {...} }` Bulk request: `[{ \"filename\": \"...\", \"type\": \"...\", \"metadata\": {...} }, ...]` ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Initiate Multipart Upload

        Initiate a multipart upload for large files. This endpoint provides the necessary information to start a multipart upload process.  Supports both single file and bulk upload requests. For bulk uploads, pass an array of upload objects (maximum 100 items). The response format matches the request format - a single object for single file requests, or an array for bulk requests.  Example CURL command (single file): ```   curl -X POST https://lilt.com/v2/upload/s3/multipart?key=API_KEY \\   --header \"Content-Type: application/json\" \\   --data-raw '{     \"filename\": \"large-file.zip\",     \"type\": \"application/zip\",     \"metadata\": {       \"size\": 104857600     }   }' ```  Example CURL command (bulk upload): ```   curl -X POST https://lilt.com/v2/upload/s3/multipart?key=API_KEY \\   --header \"Content-Type: application/json\" \\   --data-raw '[     {       \"filename\": \"large-file1.zip\",       \"type\": \"application/zip\",       \"metadata\": { \"size\": 104857600 }     },     {       \"filename\": \"large-file2.zip\",       \"type\": \"application/zip\",       \"metadata\": { \"size\": 209715200 }     }   ]' ``` 

        :param initiate_multipart_upload_body: Information about the file(s) to be uploaded. Can be a single object or an array of objects (max 100).  Single file request: `{ \"filename\": \"...\", \"type\": \"...\", \"metadata\": {...} }` Bulk request: `[{ \"filename\": \"...\", \"type\": \"...\", \"metadata\": {...} }, ...]`  (required)
        :type initiate_multipart_upload_body: InitiateMultipartUploadBody
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._initiate_multipart_upload_serialize(
            initiate_multipart_upload_body=initiate_multipart_upload_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "InitiateMultipartUpload200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _initiate_multipart_upload_serialize(
        self,
        initiate_multipart_upload_body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if initiate_multipart_upload_body is not None:
            _body_params = initiate_multipart_upload_body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth', 
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/upload/s3/multipart',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def initiate_s3_upload(
        self,
        initiate_upload_body: Annotated[InitiateUploadBody, Field(description="Information about the file(s) to be uploaded. Can be a single object or an array of objects (max 100).  Single file request: `{ \"filename\": \"...\", \"type\": \"...\", \"metadata\": {...} }` Bulk request: `[{ \"filename\": \"...\", \"type\": \"...\", \"metadata\": {...} }, ...]` ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetS3UploadParams200Response:
        """Initiate File Upload to Cloud Storage

        Initiate the upload of a file to cloud storage. This endpoint provides the necessary information to complete the file upload process.  Supports both single file and bulk upload requests. For bulk uploads, pass an array of upload objects (maximum 100 items). The response format matches the request format - a single object for single file requests, or an array for bulk requests.  Example CURL command (single file): ```   curl -X POST https://lilt.com/v2/upload/s3/params?key=API_KEY \\   --header \"Content-Type: application/json\" \\   --data-raw '{     \"filename\": \"example.json\",     \"type\": \"application/json\",     \"metadata\": {       \"size\": 1024,       \"labels\": [\"important\", \"review-needed\"]     }   }' ```  Example CURL command (bulk upload): ```   curl -X POST https://lilt.com/v2/upload/s3/params?key=API_KEY \\   --header \"Content-Type: application/json\" \\   --data-raw '[     {       \"filename\": \"file1.json\",       \"type\": \"application/json\",       \"metadata\": { \"size\": 1024 }     },     {       \"filename\": \"file2.txt\",       \"type\": \"text/plain\",       \"metadata\": { \"size\": 2048 }     }   ]' ``` 

        :param initiate_upload_body: Information about the file(s) to be uploaded. Can be a single object or an array of objects (max 100).  Single file request: `{ \"filename\": \"...\", \"type\": \"...\", \"metadata\": {...} }` Bulk request: `[{ \"filename\": \"...\", \"type\": \"...\", \"metadata\": {...} }, ...]`  (required)
        :type initiate_upload_body: InitiateUploadBody
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._initiate_s3_upload_serialize(
            initiate_upload_body=initiate_upload_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetS3UploadParams200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def initiate_s3_upload_with_http_info(
        self,
        initiate_upload_body: Annotated[InitiateUploadBody, Field(description="Information about the file(s) to be uploaded. Can be a single object or an array of objects (max 100).  Single file request: `{ \"filename\": \"...\", \"type\": \"...\", \"metadata\": {...} }` Bulk request: `[{ \"filename\": \"...\", \"type\": \"...\", \"metadata\": {...} }, ...]` ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetS3UploadParams200Response]:
        """Initiate File Upload to Cloud Storage

        Initiate the upload of a file to cloud storage. This endpoint provides the necessary information to complete the file upload process.  Supports both single file and bulk upload requests. For bulk uploads, pass an array of upload objects (maximum 100 items). The response format matches the request format - a single object for single file requests, or an array for bulk requests.  Example CURL command (single file): ```   curl -X POST https://lilt.com/v2/upload/s3/params?key=API_KEY \\   --header \"Content-Type: application/json\" \\   --data-raw '{     \"filename\": \"example.json\",     \"type\": \"application/json\",     \"metadata\": {       \"size\": 1024,       \"labels\": [\"important\", \"review-needed\"]     }   }' ```  Example CURL command (bulk upload): ```   curl -X POST https://lilt.com/v2/upload/s3/params?key=API_KEY \\   --header \"Content-Type: application/json\" \\   --data-raw '[     {       \"filename\": \"file1.json\",       \"type\": \"application/json\",       \"metadata\": { \"size\": 1024 }     },     {       \"filename\": \"file2.txt\",       \"type\": \"text/plain\",       \"metadata\": { \"size\": 2048 }     }   ]' ``` 

        :param initiate_upload_body: Information about the file(s) to be uploaded. Can be a single object or an array of objects (max 100).  Single file request: `{ \"filename\": \"...\", \"type\": \"...\", \"metadata\": {...} }` Bulk request: `[{ \"filename\": \"...\", \"type\": \"...\", \"metadata\": {...} }, ...]`  (required)
        :type initiate_upload_body: InitiateUploadBody
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._initiate_s3_upload_serialize(
            initiate_upload_body=initiate_upload_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetS3UploadParams200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def initiate_s3_upload_without_preload_content(
        self,
        initiate_upload_body: Annotated[InitiateUploadBody, Field(description="Information about the file(s) to be uploaded. Can be a single object or an array of objects (max 100).  Single file request: `{ \"filename\": \"...\", \"type\": \"...\", \"metadata\": {...} }` Bulk request: `[{ \"filename\": \"...\", \"type\": \"...\", \"metadata\": {...} }, ...]` ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Initiate File Upload to Cloud Storage

        Initiate the upload of a file to cloud storage. This endpoint provides the necessary information to complete the file upload process.  Supports both single file and bulk upload requests. For bulk uploads, pass an array of upload objects (maximum 100 items). The response format matches the request format - a single object for single file requests, or an array for bulk requests.  Example CURL command (single file): ```   curl -X POST https://lilt.com/v2/upload/s3/params?key=API_KEY \\   --header \"Content-Type: application/json\" \\   --data-raw '{     \"filename\": \"example.json\",     \"type\": \"application/json\",     \"metadata\": {       \"size\": 1024,       \"labels\": [\"important\", \"review-needed\"]     }   }' ```  Example CURL command (bulk upload): ```   curl -X POST https://lilt.com/v2/upload/s3/params?key=API_KEY \\   --header \"Content-Type: application/json\" \\   --data-raw '[     {       \"filename\": \"file1.json\",       \"type\": \"application/json\",       \"metadata\": { \"size\": 1024 }     },     {       \"filename\": \"file2.txt\",       \"type\": \"text/plain\",       \"metadata\": { \"size\": 2048 }     }   ]' ``` 

        :param initiate_upload_body: Information about the file(s) to be uploaded. Can be a single object or an array of objects (max 100).  Single file request: `{ \"filename\": \"...\", \"type\": \"...\", \"metadata\": {...} }` Bulk request: `[{ \"filename\": \"...\", \"type\": \"...\", \"metadata\": {...} }, ...]`  (required)
        :type initiate_upload_body: InitiateUploadBody
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._initiate_s3_upload_serialize(
            initiate_upload_body=initiate_upload_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetS3UploadParams200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _initiate_s3_upload_serialize(
        self,
        initiate_upload_body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if initiate_upload_body is not None:
            _body_params = initiate_upload_body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth', 
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/upload/s3/params',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def sign_upload_part(
        self,
        upload_id: Annotated[StrictStr, Field(description="Multipart upload ID from initiate response")],
        part_number: Annotated[int, Field(strict=True, ge=1, description="Part number (1-based)")],
        s3_key: Annotated[StrictStr, Field(description="Upload key from initiate response")],
        size: Annotated[int, Field(strict=True, ge=0, description="Size of this part in bytes")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SignUploadPart200Response:
        """Sign Upload Part

        Get a signed URL for uploading a specific part of a multipart upload.  Make sure to set the part size to 8MB (8388608 bytes).  Example CURL command: ```   curl -X GET \"https://lilt.com/v2/upload/s3/multipart/abc123def456/1?key=API_KEY&key=uploads/user123/file456.zip&size=5242880\" ``` 

        :param upload_id: Multipart upload ID from initiate response (required)
        :type upload_id: str
        :param part_number: Part number (1-based) (required)
        :type part_number: int
        :param s3_key: Upload key from initiate response (required)
        :type s3_key: str
        :param size: Size of this part in bytes (required)
        :type size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._sign_upload_part_serialize(
            upload_id=upload_id,
            part_number=part_number,
            s3_key=s3_key,
            size=size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SignUploadPart200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def sign_upload_part_with_http_info(
        self,
        upload_id: Annotated[StrictStr, Field(description="Multipart upload ID from initiate response")],
        part_number: Annotated[int, Field(strict=True, ge=1, description="Part number (1-based)")],
        s3_key: Annotated[StrictStr, Field(description="Upload key from initiate response")],
        size: Annotated[int, Field(strict=True, ge=0, description="Size of this part in bytes")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SignUploadPart200Response]:
        """Sign Upload Part

        Get a signed URL for uploading a specific part of a multipart upload.  Make sure to set the part size to 8MB (8388608 bytes).  Example CURL command: ```   curl -X GET \"https://lilt.com/v2/upload/s3/multipart/abc123def456/1?key=API_KEY&key=uploads/user123/file456.zip&size=5242880\" ``` 

        :param upload_id: Multipart upload ID from initiate response (required)
        :type upload_id: str
        :param part_number: Part number (1-based) (required)
        :type part_number: int
        :param s3_key: Upload key from initiate response (required)
        :type s3_key: str
        :param size: Size of this part in bytes (required)
        :type size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._sign_upload_part_serialize(
            upload_id=upload_id,
            part_number=part_number,
            s3_key=s3_key,
            size=size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SignUploadPart200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def sign_upload_part_without_preload_content(
        self,
        upload_id: Annotated[StrictStr, Field(description="Multipart upload ID from initiate response")],
        part_number: Annotated[int, Field(strict=True, ge=1, description="Part number (1-based)")],
        s3_key: Annotated[StrictStr, Field(description="Upload key from initiate response")],
        size: Annotated[int, Field(strict=True, ge=0, description="Size of this part in bytes")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Sign Upload Part

        Get a signed URL for uploading a specific part of a multipart upload.  Make sure to set the part size to 8MB (8388608 bytes).  Example CURL command: ```   curl -X GET \"https://lilt.com/v2/upload/s3/multipart/abc123def456/1?key=API_KEY&key=uploads/user123/file456.zip&size=5242880\" ``` 

        :param upload_id: Multipart upload ID from initiate response (required)
        :type upload_id: str
        :param part_number: Part number (1-based) (required)
        :type part_number: int
        :param s3_key: Upload key from initiate response (required)
        :type s3_key: str
        :param size: Size of this part in bytes (required)
        :type size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._sign_upload_part_serialize(
            upload_id=upload_id,
            part_number=part_number,
            s3_key=s3_key,
            size=size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SignUploadPart200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _sign_upload_part_serialize(
        self,
        upload_id,
        part_number,
        s3_key,
        size,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if upload_id is not None:
            _path_params['uploadId'] = upload_id
        if part_number is not None:
            _path_params['partNumber'] = part_number
        # process the query parameters
        if s3_key is not None:
            
            _query_params.append(('s3Key', s3_key))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth', 
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/upload/s3/multipart/{uploadId}/partNumber',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


